# Lab 3

## Compulsory part (必做部分)

For the compulsory part, we completed `server.c`, which employs the POSIX threads (pthreads) execution model.

### Concurrent request handling (并发请求处理)

We designed a thread pool with the `pthread.h` library,
which will be introduced in the [Optional part](#optional-part-选做部分) section.

### Parse HTTP header (解析和检验 HTTP 头)

The `parse_request()` function implements this functionality.
It first compares the first five characters with `"GET /"`, since HTTP method names (GET, POST, etc.) are case-sensitive ([source](https://datatracker.ietf.org/doc/html/rfc9110#section-9.1)).
Then, it extracts the characters between the first two spaces as the path of the requested file.
If the length of path is greater than PATH_MAX, it will return -1 (error).

### Handle request (实现读取请求资源内容)

The `handle_clnt()` function implements this functionality.
Basically, it can be divided into three individual components.

#### `read()` request

The `read()` function is called repeatedly until we get a `"\r\n\r\n"` in the string.

#### Try to `open()` file

We first test for the existence of the required file (by calling `access()`),
and then examine whether a [directory traversal attack](https://en.wikipedia.org/wiki/Directory_traversal_attack) is made (by comparing the return values from `realpath()` and `getcwd()`).
Server will respond `404 Not Found` if either is failed.
If both two tests are passed, and the file is a regular file, it will be `open()` with `O_RDONLY` mode.

#### `write()` respond and `sendfile()`

We first `write()` the respond corresponding to the status code, *without* the `O_NONBLOCK` flag.
[POSIX standard](https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html) guarantees a *complete* write.
If the status is `200 OK`, we also need to output the content of the requested files,
and this is done by `sendfile()`, which are faster than `read()` from the source and then `write()` to the target.

> Please note that `sendfile()` can transfer at most 0x7ffff000 (2,147,479,552) bytes, which is about 2 Gigabyte.
> Use `ssize_t sendfile64(int out_fd, int in_fd, off64_t * offset, size_t count)` if larger files need to be handled.

**注意，`sendfile()` 最多只能传输大约 2 GB，如果需要处理更大的文件，请使用 `sendfile64()` 函数。**（可能需要 64 位 Linux）。

### Error handling (实现错误和异常处理)

We define two function-like macros to handle errors.
The first is `errExit()`, it will `fputs()` the error message to stderr and teminate the server.
The second is `perrExit()`, it will `perror()` the error message and terminate the server, it is called when errno is set.

## Optional part (选做部分)

### Thread pool desgin (使用线程池机制)

In `server.c`, we implements a thread pool desgin.

We define a thread pool type `threadpool_t`, which is a struct containing

- A circular queue consisting of the client socket,
- A mutex used to protect the queue from concurrent access.
- Two condition variables indicating whether queue is empty or full.

The thread pool desgin works in the following steps:

1. `pthread_create()` and some pthread init functions are called to create threads.
1. Each time a file descriptor of the client socket is `accept()`, it will be pushed to the queue.
1. Each thread pops one file descriptor from the queue and handles it.

### `epoll` I/O event notification mechanism (使用 I/O 复用或异步 I/O)

In `server_optional.c`, we implements a epoll pool desgin.
Three functions, `handle_clnt()`, `parse_request()`, `write_s()` in this souce code are completely the same as those of `server.c`, and the main function is almost the same.

The epoll mechanism works in the following steps:

1. A epoll file descriptor is created by `epoll_create1()`.
1. The file descriptor of the accepted socket is wrapped as a epoll event.
1. `epoll_ctl()` is called to register the event.
1. `epoll_wait()` waits for any of the events registered with `epoll_ctl()`. It will block until a file descriptor delivers an event.
1. `handle_clnt()` will handle the events that are available.
1. Closing a file descriptor will cause it to be removed from all epoll sets automatically, therefore we do not need to deregister the corresponding event.

## Testing (测试)

We use a 200 MiB index.html for testing. The file is generated by `truncate` [command](https://ostechnix.com/create-files-certain-size-linux/).

The siege tool is in its default configuration, and we run this command for testing:

```sh
siege -c 50 -r 10 http://127.0.0.1:8000/index.html
```

### `server.c`

Compile and run:

```sh
gcc server.c -o server -lpthread -O3
./server
```

Siege result:

```text
** SIEGE 3.0.8
** Preparing 50 concurrent users for battle.
The server is now under siege..      done.

Transactions:                    500 hits
Availability:                 100.00 %
Elapsed time:                  18.13 secs
Data transferred:          100000.00 MB
Response time:                  1.11 secs
Transaction rate:              27.58 trans/sec
Throughput:                  5515.72 MB/sec
Concurrency:                   30.62
Successful transactions:         500
Failed transactions:               0
Longest transaction:            2.02
Shortest transaction:           0.06
```

### `server_optional.c`

Compile and run:

```sh
gcc server_optional.c -o server_optional -O3
./server_optional
```

Siege result:

```text
** SIEGE 3.0.8
** Preparing 50 concurrent users for battle.
The server is now under siege..      done.

Transactions:                    500 hits
Availability:                 100.00 %
Elapsed time:                  27.72 secs
Data transferred:          100000.00 MB
Response time:                  2.11 secs
Transaction rate:              18.04 trans/sec
Throughput:                  3607.50 MB/sec
Concurrency:                   38.00
Successful transactions:         500
Failed transactions:               0
Longest transaction:            2.60
Shortest transaction:           0.06
```
